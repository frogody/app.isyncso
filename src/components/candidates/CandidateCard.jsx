
import React from 'react';
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  User,
  Send,
  RefreshCw,
  ExternalLink,
  Loader2,
  MoreVertical,
  Trash2
} from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Campaign } from "@/api/entities";
import { generateCampaignOutreach } from "@/api/functions";
import { createOutreachTask } from "@/api/functions";
import CountdownTimer from "./CountdownTimer";
import { generateFollowUpMessage } from "@/api/functions";
// Removed import for hasValidLock and setLock as they are no longer used for local auto-generation

export default function CandidateCard({
  candidate,
  matchData,
  stage,
  _isExpanded,
  _onToggleExpand,
  campaign,
  user,
  onDelete,
  onCampaignUpdate
}) {
  const [outreachMessage, setOutreachMessage] = React.useState('');
  const [isGenerating, setIsGenerating] = React.useState(false);
  const [showRegenerateConfirm, setShowRegenerateConfirm] = React.useState(false);
  // Removed `hasAutoGenerated` state as local auto-generation is no longer performed.

  // Removed the previous React.useEffect for auto-generation of follow-up messages
  // as per the requirement to stop duplicate generation and handle it via AgentBacklog or manual regenerate.

  // Ensure we always pick the correct message from props when campaign updates
  React.useEffect(() => {
    if (stage === 'follow_up_1' && matchData?.follow_up_message) {
      setOutreachMessage(matchData.follow_up_message);
      return;
    }
    if (stage === 'follow_up_2' && matchData?.follow_up_message_2) {
      setOutreachMessage(matchData.follow_up_message_2);
      return;
    }
    if ((stage === 'first_message' || stage === 'queue') && matchData?.outreach_message) {
      setOutreachMessage(matchData.outreach_message);
      return;
    }
    setOutreachMessage(''); // Clear message if no match
  }, [stage, matchData?.follow_up_message, matchData?.follow_up_message_2, matchData?.outreach_message]);

  // Fallback: if follow-up stage shows no message yet, fetch once to hydrate (no reload)
  // This new hydration effect focuses ONLY on follow-up messages that might be missing from props.
  React.useEffect(() => {
    let done = false; // Flag to ensure setOutreachMessage runs only once within this effect's cycle
    const needsFU1 = stage === 'follow_up_1' && !matchData?.follow_up_message;
    const needsFU2 = stage === 'follow_up_2' && !matchData?.follow_up_message_2;
    if (!needsFU1 && !needsFU2) return; // Only interested in FU1/FU2 if message is missing

    (async () => {
      try {
        console.log(`[CandidateCard] üîÑ Hydrating missing ${stage} message from server for candidate ${candidate.id}...`);
        const freshArr = await Campaign.filter({ id: campaign.id });
        const fresh = freshArr?.[0];
        const m = fresh?.matched_candidates?.find(x => x.candidate_id === candidate.id);
        if (!m) {
          console.warn(`[CandidateCard] ‚ö†Ô∏è Candidate ${candidate.id} not found in fresh campaign data during FU hydration.`);
          return;
        }

        if (needsFU1 && m.follow_up_message && !done) {
          setOutreachMessage(m.follow_up_message);
          console.log('[CandidateCard] ‚úÖ FU1 hydrated from server');
          done = true;
        }
        if (needsFU2 && m.follow_up_message_2 && !done) {
          setOutreachMessage(m.follow_up_message_2);
          console.log('[CandidateCard] ‚úÖ FU2 hydrated from server');
          done = true;
        }
      } catch (e) {
        console.warn('[components/candidates/CandidateCard.js] Hydrate follow-up failed', e?.message);
      }
    })();
    // run once for the missing-follow-up case
  }, [stage, matchData?.follow_up_message, matchData?.follow_up_message_2, campaign?.id, candidate?.id]);


  // IMPORTANT: do not auto-generate follow-ups here; generation happens via AgentBacklog to prevent duplicates
  // This function is a no-op, provided as a placeholder if other code might call it.
  const _maybeGenerateFollowUpLocally = React.useCallback(() => {
    // Intentionally disabled to avoid duplicates and race conditions.
    // The actual generation is expected to happen server-side via Agent Backlog processes.
    return;
  }, []);

  const handleRegenerateOutreach = async () => {
    setShowRegenerateConfirm(false);
    setIsGenerating(true);
    // Removed `setHasAutoGenerated` as it's no longer used.

    try {
      let response;
      let newMessage = '';
      let updatedMatchField = '';

      if (stage === 'queue') {
        // Regenerate initial outreach
        response = await generateCampaignOutreach({
          candidate_id: candidate.id,
          campaign_id: campaign.id
        });

        const responseData = response?.data || response;
        newMessage = responseData?.outreach_message || '';
        updatedMatchField = 'outreach_message';

      } else if (stage === 'follow_up_1') {
        // Regenerate follow-up 1
        response = await generateFollowUpMessage({
          candidate_id: candidate.id,
          campaign_id: campaign.id,
          attempt_number: 1
        });

        const responseData = response?.data || response;
        newMessage = responseData?.follow_up_message || '';
        updatedMatchField = 'follow_up_message';

      } else if (stage === 'follow_up_2') {
        // Regenerate follow-up 2
        response = await generateFollowUpMessage({
          candidate_id: candidate.id,
          campaign_id: campaign.id,
          attempt_number: 2
        });

        const responseData = response?.data || response;
        newMessage = responseData?.follow_up_message || ''; // Assuming generateFollowUpMessage returns 'follow_up_message'
        updatedMatchField = 'follow_up_message_2'; // Store in specific field for FU2
      }

      if (newMessage) {
        console.log(`‚úÖ New message generated for ${stage}:`, newMessage.substring(0, 100));
        setOutreachMessage(newMessage);

        // CRITICAL: Fetch fresh campaign data
        console.log('üîÑ Fetching fresh campaign data before regenerate save...');
        const freshCampaigns = await Campaign.filter({ id: campaign.id });
        const freshCampaign = freshCampaigns[0];

        if (!freshCampaign) {
          console.error('‚ùå Campaign not found!');
          alert(user?.language === 'nl' ? 'Fout bij regenereren: Campagne niet gevonden' : 'Error regenerating: Campaign not found');
          return;
        }

        // Update campaign with fresh data
        const updatedMatches = freshCampaign.matched_candidates.map(m =>
          m.candidate_id === candidate.id
            ? { ...m, [updatedMatchField]: newMessage }
            : m
        );
        await Campaign.update(campaign.id, { matched_candidates: updatedMatches });
        console.log('üíæ Campaign updated with new message');

        // Immediately update parent UI without a full page refresh
        if (typeof onCampaignUpdate === 'function') {
          const updatedCampaign = { ...freshCampaign, matched_candidates: updatedMatches };
          onCampaignUpdate(campaign.id, updatedCampaign);
        }
      } else {
        console.warn('Manual regeneration failed to produce a new message.');
        alert(user?.language === 'nl' ? 'Fout bij regenereren: geen bericht ontvangen' : 'Error regenerating: no message received');
      }

    } catch (error) {
      console.error('‚ùå Error regenerating message:', error);
      alert(user?.language === 'nl' ? 'Fout bij regenereren' : 'Error regenerating');
    } finally {
      setIsGenerating(false);
    }
  };

  const calculateNextCheckReplyDate = () => {
    const checkReplyDate = new Date();
    let businessDays = 0;
    while (businessDays < 5) {
      checkReplyDate.setDate(checkReplyDate.getDate() + 1);
      if (checkReplyDate.getDay() !== 0 && checkReplyDate.getDay() !== 6) { // 0 is Sunday, 6 is Saturday
        businessDays++;
      }
    }
    return checkReplyDate;
  };

  const handleSendToAgent = async () => {
    if (!outreachMessage) {
      alert(user?.language === 'nl'
        ? 'Genereer eerst een outreach bericht'
        : 'Generate an outreach message first');
      return;
    }

    setIsGenerating(true); // Disable buttons during processing

    try {
      console.log('ü§ñ Sending to agent:', candidate.id);
      console.log('üìä Current stage:', stage);
      console.log('üìß Outreach message length:', outreachMessage.length);
      console.log('üéØ Campaign ID:', campaign.id);

      // Create the outreach task with the message
      const response = await createOutreachTask({
        candidate_id: candidate.id,
        campaign_id: campaign.id,
        outreach_message: outreachMessage // CRITICAL: Pass the message
      });

      console.log('üì§ Response from createOutreachTask:', response);

      const responseData = response?.data || response;

      if (responseData?.success) {
        console.log('‚úÖ Task created:', responseData.task?.id);
        console.log('üìä Task status:', responseData.task?.status);

        alert(user?.language === 'nl'
          ? 'Taak toegevoegd aan Agent Backlog!'
          : 'Task added to Agent Backlog!');

        let nextStage;
        let updateFields = {};

        // Determine next stage; follow-up messages are generated by Agent Backlog, not locally here.
        if (stage === 'queue') {
          nextStage = 'first_message';
          updateFields = {
            stage: nextStage,
            agent_task_id: responseData.task?.id,
            queued_at: new Date().toISOString(),
            next_check_reply_at: calculateNextCheckReplyDate().toISOString(),
            // `follow_up_message` will be populated by the Agent Backlog process on the backend
          };
          console.log(`Moving to next stage (${nextStage}), FU1 message generation expected from Agent Backlog.`);
        } else if (stage === 'follow_up_1') {
          nextStage = 'follow_up_2';
          updateFields = {
            stage: nextStage,
            agent_task_id: responseData.task?.id,
            queued_at: new Date().toISOString(),
            next_check_reply_at: calculateNextCheckReplyDate().toISOString(),
            // `follow_up_message_2` will be populated by the Agent Backlog process on the backend
          };
          console.log(`Moving to next stage (${nextStage}), FU2 message generation expected from Agent Backlog.`);
        } else if (stage === 'follow_up_2') {
          // After final follow-up, move to 'connected' or another final state, no further message generation
          nextStage = 'connected';
          updateFields = {
            stage: nextStage,
            agent_task_id: responseData.task?.id,
            queued_at: new Date().toISOString(),
            next_check_reply_at: null // No further follow-up check
          };
          console.log(`Moving to final stage (${nextStage}), no further message generation.`);
        } else {
          console.warn("handleSendToAgent called from unexpected stage, defaulting to first_message logic:", stage);
          nextStage = 'first_message';
          updateFields = {
            stage: nextStage,
            agent_task_id: responseData.task?.id,
            queued_at: new Date().toISOString(),
            next_check_reply_at: calculateNextCheckReplyDate().toISOString()
          };
        }

        // CRITICAL: Fetch fresh campaign data before updating
        console.log('üîÑ Fetching fresh campaign data before saving task/stage updates...');
        const freshCampaigns = await Campaign.filter({ id: campaign.id });
        const freshCampaign = freshCampaigns[0];

        if (!freshCampaign) {
          console.error('‚ùå Campaign not found!');
          alert(user?.language === 'nl' ? 'Fout: Campagne niet gevonden bij update' : 'Error: Campaign not found during update');
          return; // Exit if campaign not found
        }

        // Update campaign: Move to next stage (using freshCampaign data)
        const updatedMatches = freshCampaign.matched_candidates.map(m =>
          m.candidate_id === candidate.id
            ? { ...m, ...updateFields }
            : m
        );

        console.log(`üíæ Updating campaign, moving to ${nextStage} stage`);
        await Campaign.update(campaign.id, { matched_candidates: updatedMatches });
        console.log('‚úÖ Campaign updated successfully');

        // Immediately update parent UI without a full page refresh
        if (typeof onCampaignUpdate === 'function') {
          const updatedCampaign = { ...freshCampaign, matched_candidates: updatedMatches };
          onCampaignUpdate(campaign.id, updatedCampaign);
        }
      } else {
        throw new Error(responseData?.error || 'Failed to create task');
      }
    } catch (error) {
      console.error('‚ùå Error sending to agent:', error);
      alert(user?.language === 'nl'
        ? 'Fout bij toevoegen aan agent'
        : 'Error adding to agent');
    } finally {
      setIsGenerating(false); // Re-enable buttons
    }
  };

  const handleDeleteFromCampaign = async () => {
    const confirmed = window.confirm(
      user?.language === 'nl'
        ? `Weet je zeker dat je ${candidate.first_name} ${candidate.last_name} uit deze campagne wilt verwijderen?`
        : `Are you sure you want to remove ${candidate.first_name} ${candidate.last_name} from this campaign?`
    );

    if (!confirmed) return;

    try {
      console.log('üóëÔ∏è Removing candidate from campaign:', candidate.id);

      // CRITICAL: Fetch fresh campaign data before updating
      console.log('üîÑ Fetching fresh campaign data before deleting candidate...');
      const freshCampaigns = await Campaign.filter({ id: campaign.id });
      const freshCampaign = freshCampaigns[0];

      if (!freshCampaign) {
        console.error('‚ùå Campaign not found!');
        alert(user?.language === 'nl' ? 'Fout: Campagne niet gevonden bij verwijdering' : 'Error: Campaign not found during removal');
        return;
      }

      // Remove candidate from matched_candidates array (using freshCampaign data)
      const updatedMatches = freshCampaign.matched_candidates.filter(
        m => m.candidate_id !== candidate.id
      );

      await Campaign.update(campaign.id, {
        matched_candidates: updatedMatches
      });

      console.log('‚úÖ Candidate removed from campaign');

      // Immediately update parent UI without a full page refresh
      if (typeof onCampaignUpdate === 'function') {
        const updatedCampaign = { ...freshCampaign, matched_candidates: updatedMatches };
        onCampaignUpdate(campaign.id, updatedCampaign);
      }

      // Notify parent component if callback provided
      if (onDelete) {
        onDelete(candidate.id);
      }

    } catch (error) {
      console.error('‚ùå Error removing from campaign:', error);
      alert(user?.language === 'nl'
        ? 'Fout bij verwijderen uit campagne'
        : 'Error removing from campaign');
    }
  };

  // Helper functions for stage display
  const getStageLabel = () => {
    if (stage === 'queue') return user?.language === 'nl' ? 'Wachtend' : 'Waiting';
    if (stage === 'first_message') return user?.language === 'nl' ? 'In wachtrij' : 'Queued';
    if (stage === 'follow_up_1') return user?.language === 'nl' ? 'Follow-up 1' : 'Follow-up 1';
    if (stage === 'follow_up_2') return user?.language === 'nl' ? 'Follow-up 2' : 'Follow-up 2';
    if (stage === 'connected') return user?.language === 'nl' ? 'Verbonden' : 'Connected';
    return stage;
  };

  const getStageColor = () => {
    if (stage === 'queue') return 'rgba(156, 163, 175, 0.2)';
    if (stage === 'first_message') return 'rgba(96, 165, 250, 0.2)';
    if (stage === 'follow_up_1') return 'rgba(251, 191, 36, 0.2)';
    if (stage === 'follow_up_2') return 'rgba(251, 146, 60, 0.2)';
    if (stage === 'connected') return 'rgba(134, 239, 172, 0.2)';
    return 'rgba(156, 163, 175, 0.2)';
  };

  const getStageDescription = () => {
    if (stage === 'first_message') {
      return user?.language === 'nl'
        ? 'In wachtrij om verzonden te worden via Agent Backlog'
        : 'Queued to be sent via Agent Backlog';
    }
    if (stage === 'follow_up_1' && matchData?.next_check_reply_at) {
      return user?.language === 'nl'
        ? 'Wacht op reply check, daarna automatisch verzonden'
        : 'Waiting for reply check, then auto-send';
    }
    if (stage === 'follow_up_2' && matchData?.next_check_reply_at) {
      return user?.language === 'nl'
        ? 'Laatste follow-up, wacht op reply check'
        : 'Final follow-up, waiting for reply check';
    }
    return ''; // Default empty if no specific description
  };

  // Show countdown and message for queue and follow-up stages
  const showCountdown = (stage === 'follow_up_1' || stage === 'follow_up_2') && matchData?.next_check_reply_at;
  const showMessage = stage === 'queue' || stage === 'follow_up_1' || stage === 'follow_up_2';

  return (
    <Card
      className="glass-card transition-all hover:scale-[1.01]"
      style={{
        background: `linear-gradient(180deg, ${getStageColor()}, rgba(26,32,38,.35))`,
        border: '1px solid rgba(255,255,255,.06)'
      }}
    >
      <CardContent className="p-4">
        <div className="flex items-start gap-3">
          {/* Profile Picture */}
          <div
            className="w-12 h-12 rounded-full flex-shrink-0 flex items-center justify-center"
            style={{ background: 'rgba(233, 240, 241, 0.1)' }}
          >
            {candidate.profile_picture ? (
              <img
                src={candidate.profile_picture}
                alt={`${candidate.first_name} ${candidate.last_name}`}
                className="w-full h-full rounded-full object-cover"
              />
            ) : (
              <User className="w-6 h-6" style={{ color: 'rgba(233, 240, 241, 0.4)' }} />
            )}
          </div>

          {/* Content */}
          <div className="flex-1 min-w-0">
            <div className="flex items-start justify-between gap-2 mb-2">
              <div className="flex-1 min-w-0">
                <h3 className="font-semibold text-sm truncate" style={{ color: 'var(--txt)' }}>
                  {candidate.first_name} {candidate.last_name}
                </h3>
                <p className="text-xs truncate" style={{ color: 'rgba(181, 192, 196, 0.7)' }}>
                  {candidate.job_title}
                </p>
                <p className="text-xs truncate" style={{ color: 'rgba(181, 192, 196, 0.5)' }}>
                  {candidate.company_name}
                </p>
              </div>

              {/* Actions Dropdown */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 flex-shrink-0"
                  >
                    <MoreVertical className="w-4 h-4" style={{ color: 'var(--muted)' }} />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent
                  align="end"
                  className="glass-card border"
                  style={{
                    background: 'rgba(15,20,24,.98)',
                    borderColor: 'rgba(255,255,255,.08)'
                  }}
                >
                  {/* LinkedIn profile link (if available) */}
                  {candidate.linkedin_profile && (
                    <DropdownMenuItem
                      onClick={() => window.open(candidate.linkedin_profile, '_blank')}
                      style={{ color: 'var(--txt)' }}
                    >
                      <ExternalLink className="w-4 h-4 mr-2" />
                      {user?.language === 'nl' ? 'Open LinkedIn' : 'Open LinkedIn'}
                    </DropdownMenuItem>
                  )}

                  {candidate.linkedin_profile && <DropdownMenuSeparator style={{ background: 'rgba(255,255,255,.06)' }} />}

                  <DropdownMenuItem
                    onClick={handleDeleteFromCampaign}
                    style={{ color: '#EF4444' }}
                  >
                    <Trash2 className="w-4 h-4 mr-2" />
                    {user?.language === 'nl' ? 'Verwijderen' : 'Remove'}
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>

            {/* Stage Badge & Countdown */}
            <div className="flex items-center gap-2 mb-3">
              <Badge
                className="text-[10px] px-2 py-0.5"
                style={{
                  background: getStageColor(),
                  color: 'var(--txt)',
                  border: '1px solid rgba(255,255,255,.1)'
                }}
              >
                {getStageLabel()}
              </Badge>

              {/* Countdown Timer with explanation */}
              {showCountdown && (
                <div className="flex flex-col gap-0.5">
                  <CountdownTimer
                    targetDate={matchData.next_check_reply_at}
                    user={user}
                  />
                  <p className="text-[9px] leading-tight" style={{ color: 'rgba(181, 192, 196, 0.4)' }}>
                    {getStageDescription()}
                  </p>
                </div>
              )}
            </div>

            {/* Show message for queue and follow-up stages */}
            {showMessage && (
              <>
                {outreachMessage ? (
                  <div className="space-y-3">
                    <div
                      className="p-3 rounded-lg text-xs leading-relaxed"
                      style={{
                        background: 'rgba(255,255,255,.02)',
                        color: 'rgba(233, 240, 241, 0.8)',
                        border: '1px solid rgba(255,255,255,.04)'
                      }}
                    >
                      {outreachMessage}
                    </div>

                    <div className="flex gap-2">
                      <Button
                        onClick={handleSendToAgent}
                        disabled={!outreachMessage || isGenerating} // Disable if no message or generating
                        size="sm"
                        className="flex-1 h-8 text-xs"
                        style={{
                          background: 'rgba(134, 239, 172, 0.12)',
                          color: '#86EFAC',
                          border: '1px solid rgba(134, 239, 172, 0.3)'
                        }}
                      >
                        <Send className="w-3 h-3 mr-1.5" />
                        {user?.language === 'nl' ? 'Naar Agent' : 'Send to Agent'}
                      </Button>

                      <Button
                        onClick={() => setShowRegenerateConfirm(true)}
                        disabled={isGenerating} // Disable if generating
                        size="sm"
                        variant="ghost"
                        className="h-8 px-2"
                        style={{ color: 'var(--muted)' }}
                      >
                        <RefreshCw className="w-3 h-3" />
                      </Button>
                    </div>

                    {showRegenerateConfirm && (
                      <div
                        className="p-3 rounded-lg space-y-2"
                        style={{ background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.2)' }}
                      >
                        <p className="text-xs" style={{ color: '#FFCCCB' }}>
                          {user?.language === 'nl'
                            ? 'Weet je zeker dat je het bericht opnieuw wilt genereren?'
                            : 'Are you sure you want to regenerate the message?'}
                        </p>
                        <div className="flex gap-2">
                          <Button
                            onClick={handleRegenerateOutreach} // Consolidated to single function
                            disabled={isGenerating}
                            size="sm"
                            className="flex-1 h-7 text-xs"
                            style={{
                              background: 'rgba(239, 68, 68, 0.2)',
                              color: '#FFCCCB',
                              border: '1px solid rgba(239, 68, 68, 0.3)'
                            }}
                          >
                            {isGenerating ? (
                              <>
                                <Loader2 className="w-3 h-3 mr-1.5 animate-spin" />
                                {user?.language === 'nl' ? 'Bezig...' : 'Generating...'}
                              </>
                            ) : (
                              user?.language === 'nl' ? 'Ja, regenereer' : 'Yes, regenerate'
                            )}
                          </Button>
                          <Button
                            onClick={() => setShowRegenerateConfirm(false)}
                            size="sm"
                            variant="ghost"
                            className="h-7 text-xs"
                            style={{ color: 'var(--muted)' }}
                          >
                            {user?.language === 'nl' ? 'Annuleren' : 'Cancel'}
                          </Button>
                        </div>
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="text-center py-4">
                    <p className="text-xs mb-2" style={{ color: 'var(--muted)' }}>
                      {isGenerating
                        ? (user?.language === 'nl' ? 'Bezig met genereren...' : 'Generating message...')
                        : (user?.language === 'nl' ? 'Geen bericht gevonden, controleren...' : 'No message found, checking server...')}
                    </p>
                    {isGenerating && <Loader2 className="h-4 w-4 animate-spin mx-auto text-current" />}
                  </div>
                )}
              </>
            )}

            {/* First message stage: Show waiting state */}
            {stage === 'first_message' && (
              <div className="text-xs p-3 rounded-lg" style={{
                background: 'rgba(96, 165, 250, 0.1)',
                border: '1px solid rgba(96, 165, 250, 0.2)',
                color: 'rgba(233, 240, 241, 0.7)'
              }}>
                <p className="font-medium mb-1" style={{ color: '#60A5FA' }}>
                  {user?.language === 'nl' ? '‚úâÔ∏è Bericht in wachtrij' : '‚úâÔ∏è Message queued'}
                </p>
                <p>
                  {getStageDescription()}
                </p>
              </div>
            )}

            {/* Connected stage: Show reply */}
            {stage === 'connected' && matchData?.reply_content && (
              <div
                className="p-3 rounded-lg text-xs mt-2"
                style={{
                  background: 'rgba(134, 239, 172, 0.1)',
                  border: '1px solid rgba(134, 239, 172, 0.2)',
                  color: 'rgba(233, 240, 241, 0.8)'
                }}
              >
                <p className="font-semibold mb-2" style={{ color: '#86EFAC' }}>
                  {user?.language === 'nl' ? 'üí¨ Reactie:' : 'üí¨ Reply:'}
                </p>
                <p className="leading-relaxed">{matchData.reply_content}</p>
              </div>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
